package org.neuroph.netbeans.classificationsample;

import java.awt.datatransfer.Transferable;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.util.ArrayList;
import org.netbeans.api.settings.ConvertAsProperties;
import org.neuroph.core.NeuralNetwork;
import org.neuroph.core.events.LearningEvent;
import org.neuroph.core.events.LearningEventListener;
import org.neuroph.core.data.DataSet;
import org.neuroph.netbeans.visual.TrainingController;
import org.neuroph.netbeans.visual.NeuralNetAndDataSet;
import org.neuroph.netbeans.project.NeurophProjectFilesFactory;
import org.neuroph.nnet.learning.LMS;
import org.neuroph.nnet.learning.MomentumBackpropagation;
import org.openide.nodes.Node;
import org.openide.nodes.NodeTransfer;
import org.openide.util.Lookup;
import org.openide.util.NbBundle;
import org.openide.util.lookup.AbstractLookup;
import org.openide.util.lookup.InstanceContent;
import org.openide.util.lookup.Lookups;
import org.openide.util.lookup.ProxyLookup;
import org.openide.windows.TopComponent;

/**
 * Top component which displays visualization of data set na multi layer perceptron classification.
 */
@ConvertAsProperties(dtd = "-//org.neuroph.netbeans.classificationsample.mlperceptron//MultiLayerPerceptronVisualizationTopComponent//EN",
        autostore = false)
public final class MultiLayerPerceptronVisualizationTopComponent extends TopComponent implements LearningEventListener {

    private static final String PREFERRED_ID = "MultiLayerPerceptronVisualizationTopComponent";
    private static int topComponentCount=0; // koristi se za brojanje prozora i davanje imena prozorima, mozd bi zgodnije bilo da se prozori nazovu po neuronskim mrezama koje sadrze
    private int tsCount = 0; // use for naming newly created datasets 
    
    // top components infrastructure
    private InstanceContent content;
    private AbstractLookup aLookup;
    private DropTargetListener dtListener;
    private DropTarget dropTarget;
    private final int acceptableActions = DnDConstants.ACTION_COPY;    
    
    // MLP sample controlls top component
    private MultiLayerPerceptronClassificationSamplePanel controllsPanel; // trebalo bi gadjati ovaj TC a ne panel ispod ... nema porebe za obe reference zbunjujuce su. Jos bolje bi bilo kad bi ovaj slusao sa listenerom
    private MlpClassificationSampleControlsTopComponent sampleControllsTC;

    // neural nnetwork and data set    
    private DataSet trainingSet;
    private NeuralNetwork neuralNetwork;
    private NeuralNetAndDataSet neuralNetAndDataSet;
    private TrainingController trainingController;
        
    // values and buffers used for visualization
    private ArrayList<Double> valuesForInputs; // generisane vrednosti sa x i y ose koje se korite kao ulaz za vizuelizaciju; - ovo ne mora da se cuva nego da se vrti kroz petlju    
    private ArrayList<double[]> neuralNetworkInputs; // ulazni vektor za neuronsku mrezu koji se kreira od generisanih vrednosti (sadrzi sve moguce kombinacije(varijacije) vrednosti iznad
        
    // visualization settings and parameters 
    private final int gridCellSize = 80; // 80 koliko ima grid cell tacaka panelWidth / 10 na svakih 10 pixela?
    private final double pixelValue = 0.0253; //0.025316456; - value range / number of pixels
    private int[] selectedInputs; // indexes of inputs selected for visualization. this values are set through dialog
    private int learningIterationCounter = 0;
    private boolean isReadyToTrain = false; // initialized when nn and dset are available and set from initTraining
    
    
    public MultiLayerPerceptronVisualizationTopComponent() {
        initComponents();
        topComponentCount++;
        setName(NbBundle.getMessage(MultiLayerPerceptronVisualizationTopComponent.class, "CTL_MultiLayerPerceptronSampleTopComponent") + " " +topComponentCount);
        setToolTipText(NbBundle.getMessage(MultiLayerPerceptronVisualizationTopComponent.class, "HINT_MultiLayerPerceptronSampleTopComponent"));
        putClientProperty(TopComponent.PROP_UNDOCKING_DISABLED, Boolean.TRUE);
        putClientProperty(TopComponent.PROP_UNDOCKING_DISABLED, Boolean.TRUE);
        
        content = new InstanceContent();
        content.add(this);
        aLookup = new AbstractLookup(content);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        clearButton = new javax.swing.JButton();
        visualizationPanel = new org.neuroph.netbeans.classificationsample.Visualization2DPanel();

        setLayout(new java.awt.BorderLayout());

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.LINE_AXIS));

        org.openide.awt.Mnemonics.setLocalizedText(clearButton, org.openide.util.NbBundle.getMessage(MultiLayerPerceptronVisualizationTopComponent.class, "MultiLayerPerceptronVisualizationTopComponent.clearButton.text")); // NOI18N
        clearButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearButtonActionPerformed(evt);
            }
        });
        jPanel1.add(clearButton);

        add(jPanel1, java.awt.BorderLayout.PAGE_START);

        javax.swing.GroupLayout visualizationPanelLayout = new javax.swing.GroupLayout(visualizationPanel);
        visualizationPanel.setLayout(visualizationPanelLayout);
        visualizationPanelLayout.setHorizontalGroup(
            visualizationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 818, Short.MAX_VALUE)
        );
        visualizationPanelLayout.setVerticalGroup(
            visualizationPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 769, Short.MAX_VALUE)
        );

        add(visualizationPanel, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void clearButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearButtonActionPerformed
        clear();
    }//GEN-LAST:event_clearButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clearButton;
    private javax.swing.JPanel jPanel1;
    private org.neuroph.netbeans.classificationsample.Visualization2DPanel visualizationPanel;
    // End of variables declaration//GEN-END:variables

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }

    @Override
    public Lookup getLookup() {
        return new ProxyLookup(new Lookup[]{
            super.getLookup(),
            aLookup
        });
    }

    @Override
    public void componentOpened() {
    }

    @Override
    public void componentClosed() {
        // TODO add custom code on component closing
    }

    void writeProperties(java.util.Properties p) {
        // better to version settings since initial version as advocated at
        // http://wiki.apidesign.org/wiki/PropertyFiles
        p.setProperty("version", "1.0");
        // TODO store your settings
    }

    Object readProperties(java.util.Properties p) {
        readPropertiesImpl(p);
        return this;
    }

    private void readPropertiesImpl(java.util.Properties p) {
        String version = p.getProperty("version");
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }

    public DataSet getTrainingSet() {
        return trainingSet;
    }

    public void setTrainingSet(DataSet trainingSet) {
        this.trainingSet = trainingSet;
    }

    public NeuralNetwork getNeuralNetwork() {
        return neuralNetwork;
    }

    public void setNeuralNetwork(NeuralNetwork neuralNetwork) {
        this.neuralNetwork = neuralNetwork;
    }

    public Visualization2DPanel getVisualizationPanel() {
        return visualizationPanel;
    }

    public void setVisualizationPanel(Visualization2DPanel inputSpacePanel) {
        this.visualizationPanel = inputSpacePanel;
    }

    public boolean isAllPointsRemoved() {
        return visualizationPanel.isAllPointsRemoved();
    }

    public boolean isPointDrawed() {
        return visualizationPanel.isPointDrawed();
    }


    public void setDrawingPointsDisabled(boolean flag) {
        visualizationPanel.setDrawingPointsDisabled(flag);
    }

    /*
     * If point is drawed on panel, this method registers that event
     */
    public void setPointDrawed(boolean drawed) {
        visualizationPanel.setPointDrawn(drawed);
    }
      
    /**
     * Generise sve moguce varijacije ulaza u prostoru za vizuelizaciju koji se koriste za ulaz u neuronsku mrezu
     * Elementi 'valuesForInputs' su vrednosti sa koordinate, a dimenzija ulaznog vektora odgovara klasi varijacija
     *  i sve se skladisti u neuralNetworkInputs
     */
    public void generateInputSpace() {     
            if (isReadyToTrain) {       // probably not neede since this would never be called if its not ready                                                                              
                if (visualizationPanel.positiveInputsOnly()) {
                    generateValuesForInputs(gridCellSize, 0.025316456/2.0); //this was 57
                } else {
                    generateValuesForInputs(gridCellSize, 0.025316456);                                                                                     
                }
                               
                // vrednosti obe ose iskombinuj za sve ulaze neuronske mreze (ne samo za dva izabrana)
                neuralNetworkInputs = Combinatorics.Variations.generateVariations(valuesForInputs, neuralNetAndDataSet.getNetwork().getInputsCount(), true);
                               
                // visualize dataset
                if (MultiLayerPerceptronClassificationSamplePanel.SHOW_POINTS && isAllPointsRemoved() || isPointDrawed()) { // TODO: ovo treba promeniti da ne bud estatik nego nekako povezano - mozda neki objekat u backgroundu 
                    drawPointsFromDataSet(neuralNetAndDataSet.getDataSet(), selectedInputs);
                }
            }       
    }    

    /*
     * Draws points from dataset, with 2 specified inputs
     */
    public void drawPointsFromDataSet(DataSet dataSet, int[] inputs) {
            visualizationPanel.setAllPointsRemoved(false);
            visualizationPanel.drawPointsFromDataSet(dataSet, inputs);
    }

    /**
     * Creates new form BackpropagationSample
     * used in ViewManager probably not needed anymore
     */
    public void setTrainingSetForMultiLayerPerceptronSample(ObservableTrainingSet ps) {
        trainingSet = new DataSet(2, 1);
        
        sampleControllsTC = MlpClassificationSampleControlsTopComponent.findInstance();
        controllsPanel = sampleControllsTC.getSampleControlsPanel();
        controllsPanel.setMlpSampleTc(this);
        sampleControllsTC.open();
      
        this.dtListener = new DTListener();
        this.dropTarget = new DropTarget(
                this,
                this.acceptableActions,
                this.dtListener,
                true);
    }

    /*
     * Creates neural network file within selected project
     */
    public void createNeuralNetworkFile(NeuralNetwork neuralNetwork) {
        NeurophProjectFilesFactory.getDefault().createNeuralNetworkFile(neuralNetwork);
    }

    /*
     * If custom (manual) dataset is specified, training set and training set name is created
     */
    public void customDataSetCheck() {
        if (visualizationPanel.isPointDrawed()) {
            trainingSet = visualizationPanel.getTrainingSet();
            tsCount++;
            trainingSet.setLabel("MlpSampleTrainingSet" + tsCount);
        }
    }

    /*
     * If custom (manual) dataset is specified, training set file is created
     */
    public void sampleTrainingSetFileCheck() {
        if (visualizationPanel.isPointDrawed()) {
            NeurophProjectFilesFactory.getDefault().createTrainingSetFile(trainingSet);
            visualizationPanel.setPointDrawn(false);
        }
    }

    /*
     * During training mode, if Show Points check box is selected, redrawing of dataset is required
     */
    public void showPointsOptionCheck() {
        if (MultiLayerPerceptronClassificationSamplePanel.SHOW_POINTS && visualizationPanel.isAllPointsRemoved()) {
                visualizationPanel.setAllPointsRemoved(false);
                drawPointsFromDataSet(trainingSet, selectedInputs);
        }
    }

    /*
     * Collects all the information needed for training neural network
     * Called after the neural network and data set are set(dropped to this window)
     */
    public void initTraining() {
        isReadyToTrain = true;
        neuralNetwork.getLearningRule().addListener(this);//adds learning rule to observer
        trainingController.setLmsParams(controllsPanel.getLearningRate(), controllsPanel.getMaxError(), controllsPanel.getMaxIteration());
       
        LMS learningRule = (LMS) this.neuralNetAndDataSet.getNetwork().getLearningRule();
        if (learningRule instanceof MomentumBackpropagation) {
            ((MomentumBackpropagation) learningRule).setMomentum(controllsPanel.getMomentum());
        }
        
        visualizationPanel.setNeuronColors(neuralNetwork);

    }

    /*
     * Stops training
     */
    public void stop() {
        neuralNetAndDataSet.stopTraining();
    }

    /*
     * Clears all points from panel
     */
    public void clear() {
        visualizationPanel.clearPoints();
    }

    /*
     * Generates set values from [-k,k] domain, in order to simulate space of all possible neural network inputs.
     * This set is later used for generating variations with repetition of class k=numberOfinputs.
     * For each variation (in our case simulated input) we choose exactly 2 inputs for 2D visualization*
     * calle d from toolbar
     * @param size number of grid points (panelWidth / gridCellSize)
     * @param coef step, korak podeoka
     */
    public ArrayList<Double> generateValuesForInputs(int size, double coef) { // skup vrednosti na jednoj osi, podeoci na x osi
        valuesForInputs = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            double value = 1 - i * coef;
            valuesForInputs.add(value);
        }
        return valuesForInputs;
    }

    /*
     * Removes neural network and dataset from lookup content
     * Still used from MultiLayerPerceptronClassificationSamplePanel
     */
    public void removeNetworkAndDataSetFromContent() {
                if  (neuralNetAndDataSet!= null) content.remove(neuralNetAndDataSet);
                if (trainingController != null) content.remove(trainingController);
        
        requestActive();
    }

    /*
     * Regarding selected dataset, this method initializes different coordinate system
     * Check wheather the data set contains negative or only positive values
     */
    public void coordinateSystemDomainCheck() {
        boolean onlyPositive = true;//only positive inputs are detected
        loop:
        for (int i = 0; i < trainingSet.size(); i++) {
            double[] inputs = trainingSet.getRowAt(i).getInput();
            for (int j = 0; j < inputs.length; j++) {
                if (inputs[j] < 0) {
                    onlyPositive = false;//both positive and negative inputs are detected
                    break loop;
                }
            }
        }
  
        sampleControllsTC.getSampleControlsPanel().setCheckPoints(onlyPositive); //updating Swing components 
    }

    /*
     * This method shows the information, eg. current name of dataset and neural network that are used for training
     */
    public void updateNeuralNetAndDataSetInfo(NeuralNetwork neuralNetvork, DataSet dataSet) {

        MultiLayerPerceptronClassificationSamplePanel mlp = sampleControllsTC.getSampleControlsPanel();
        if (dataSet != null) {
            if (dataSet.getLabel() != null) {
                mlp.setDataSetInformation(dataSet.getLabel());
            } else {
                mlp.setDataSetInformation("Not selected");
            }
        } else {
            mlp.setDataSetInformation("Not selected");
        }
        if (neuralNetvork != null) {
            if (neuralNetvork.getLabel() != null) {
                mlp.setNeuralNetworkInformation(neuralNetvork.getLabel());
            } else {
                mlp.setNeuralNetworkInformation("Not selected");
            }
        } else {
            mlp.setNeuralNetworkInformation("Not selected");
        }
    }

    
   private void onStart() {      
        controllsPanel.setVisualizationOptions();
        setDrawingPointsDisabled(true);       
        generateInputSpace(); // fills neuralNetworkInputs with vectors 
        visualizationPanel.prepareTrainingBuffers() ;
        visualizationPanel.setVisualizationStarted(true);
    }    
    
    /**
     * Actual drawing is triggered from here after each 10th learning  teration
     * @param le learning event object
     */
    @Override
    public void handleLearningEvent(LearningEvent le) {
        if (learningIterationCounter==0) {
            onStart();
        }
            
        learningIterationCounter++;
        
        if (learningIterationCounter % 10 == 0) { // redraw after 10 learning iterations          
            NeuralNetwork nnet = neuralNetAndDataSet.getNetwork();
//            nnet.pauseLearning();//pause
           //trainingController.pause();
           // visualizeNeuralNetworkAnswer(nnet);//calculating network response and draw it
             visualizeNeuralNetworkAnswer(nnet);
           // caka je u tome sto je veci deo ove metode u repoaint i izvrsava se u drugom threadu - ovde bi trebal aneka sinhronizacija sa Gui Threadim
//            nnet.resumeLearning();//resume ovo bi trebalo da bude pozvano iz drugog threada ... onog kad zavrsi scrtanje , pitanje je i koji tread ovo kontrolise jer se ovde koristi TrainingController 
            //trainingController.resume();
        }
        
    }    
    
    /*
     * Ovde se radi glavno iscrtavanje - pocni da proucavas i ispeglajodavde
     *    
     * During neural network training process, at  particular moment, the same process pauses for a moment,
     * and neural network is passed as an function argument.
     * This method simulates all the network inputs in selected domain: [-1,1] or [0,1].
     * These inputs serve as inputs to trained network.
     * Once the output is calculated, through each iteration, panel is updated with all 
     * current outputs, and specific training result is shown on panel.
     * This process repeats itself until the training is completed.
     */
    public void visualizeNeuralNetworkAnswer(NeuralNetwork nn) {

            double initialCoordinate;   // za sta se koristi ovo - fix za pozitivne ili negativne koordinate

             // Sets parameters either only for positive inputs or positive and negative inputs
            if (visualizationPanel.positiveInputsOnly()) {
                initialCoordinate = 0.0;
            } else {
                initialCoordinate = 1.0; // sa nula crta u trecem kvadranu u crveno
            }
                
            double[] input;
            
            for (int i = 0; i < neuralNetworkInputs.size(); i++) {
                input = neuralNetworkInputs.get(i);
                
                // input je ulaz za neuronsku mrezu                
                nn.setInput(input);
                nn.calculate();
                double output = nn.getLayerAt(nn.getLayersCount() - 1).getNeuronAt(0).getOutput(); // get network output
                
                // take input values that are choosed for visualization               
                double xInput = input[selectedInputs[0]] + initialCoordinate;
                double yInput = input[selectedInputs[1]] + initialCoordinate;

                // ovo iscrtati jednom u offscreen slici i onda posle samo iskoristiti, ne ponavljati iscrtavanje?
                int x; // sta su x i y - grid points indexes?
                int y;
                
                /*
                 * Transformation from Descartes' coordintes to panel coordinates (grid points)
                 */
                if (visualizationPanel.positiveInputsOnly()) {
                    x = (int) Math.abs(xInput * (gridCellSize-1));
                    y = (gridCellSize-1) - (int) Math.abs(yInput * (gridCellSize-1));
                } else {
                    x = (int) Math.abs((xInput) / pixelValue); // da vidis koliko je pixela x
                    y = (gridCellSize-1) - (int) Math.abs((yInput) / pixelValue); //  79 - kako da ovaj dodje do nule   79 - 
                }
                // da li dobro izracunavam output, zasto su svi crveni?
                visualizationPanel.setGridPoint(x, y, output);                
            }
            visualizationPanel.repaint(); // ovo ide u drugom Gui Threadu
    }

    
 



    void setSelectedInputs(int[] selectedInputs) {
        this.selectedInputs = selectedInputs;
    }

    public int[] getSelectedInputs() {
        return selectedInputs;
    }

    
    

    /**
     * This class handles drag n drop
     */
    class DTListener implements DropTargetListener {

        @Override
        public void dragEnter(DropTargetDragEvent dtde) {
            dtde.acceptDrag(dtde.getDropAction());
        }

        @Override
        public void dragExit(DropTargetEvent dte) {
        }

        @Override
        public void dragOver(DropTargetDragEvent dtde) {
            dtde.acceptDrag(dtde.getDropAction());
        }

        @Override
        public void dropActionChanged(DropTargetDragEvent dtde) {
            dtde.acceptDrag(dtde.getDropAction());
        }

        @Override
        public void drop(DropTargetDropEvent e) {
            Transferable transferable = e.getTransferable();
            Node node = NodeTransfer.node(transferable, NodeTransfer.DND_COPY_OR_MOVE);

            DataSet dropedDataSet = node.getLookup().lookup(DataSet.class);               // get the DataSet objects from node lookup
            NeuralNetwork dropedNeuralNet = node.getLookup().lookup(NeuralNetwork.class); // get the NeuralNetwrok object from node lookup

            // if dataset is dropped
            if (dropedDataSet != null) {
                clear();
                setPointDrawed(false);
                visualizationPanel.setDrawingPointsDisabled(true);
                trainingSet = dropedDataSet;
                SelectInputsDialog selInputsDlg = new SelectInputsDialog(MultiLayerPerceptronVisualizationTopComponent.this);
                selInputsDlg.setVisible(true);
                updateNeuralNetAndDataSetInfo(neuralNetwork, trainingSet);
                coordinateSystemDomainCheck();
                visualizationPanel.drawPointsFromDataSet(trainingSet, selectedInputs); // isd.getSelectedInputs()
            }

            // if neural network is dropped
            if (dropedNeuralNet != null) {
                setNeuralNetwork(dropedNeuralNet);
                visualizationPanel.setNeuralNetwork(dropedNeuralNet);
                updateNeuralNetAndDataSetInfo(dropedNeuralNet, trainingSet);
            }
            
            if ((trainingSet != null) && (getNeuralNetwork() != null)) {
                // update neuralNetAndDataSet and trainingController in lookup
                if  (neuralNetAndDataSet!= null) content.remove(neuralNetAndDataSet);
                if (trainingController != null) content.remove(trainingController);
                neuralNetAndDataSet = new NeuralNetAndDataSet(neuralNetwork, trainingSet);
                trainingController = new TrainingController(neuralNetAndDataSet);                                
                content.add(neuralNetAndDataSet);
                content.add(trainingController);
                
                updateNeuralNetAndDataSetInfo(getNeuralNetwork(), trainingSet);
                
                initTraining();                                
                requestActive();
            }

            e.dropComplete(true);
        }
    }

    public void setSampleControllsTC(MlpClassificationSampleControlsTopComponent sampleControllsTC) {
        this.sampleControllsTC = sampleControllsTC;
    }
    
    
    
}
